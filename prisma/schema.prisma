generator client {
    provider = "prisma-client-js"
    previewFeatures = ["omitApi"]
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}





model University {
    createdAt   DateTime  @default(now())
    updatedAt   DateTime  @updatedAt
    id          String    @id @default(cuid())

    domain      String    @unique // "... .edu"
    name        String
    color       String
    users       User[]    
} 



model User {
    createdAt           DateTime            @default(now())
    updatedAt           DateTime            @updatedAt
    id                  String              @id @default(cuid())

    password            String
    salt                String

    username            String              @unique
    email               String              @unique
    displayName         String
    pfpKey              String              @default("")

    universityId        String?
    university          University?         @relation(fields: [universityId], references: [id])

    verified            Boolean             @default(false)

    posts               Post[]              @relation("UserPost")

    // All posts a user has liked
    likes              Like[]              @relation("UserLikes")

    // All reports this user has made on posts
    reports             PostReport[]        @relation("Reporter")

    // Auth tokens issued to a user. ALL tokens in the array are valid
    authTokens          AuthToken[]         @relation("UserAuthToken")
    // Reset password tokens issued to a user. Only the last token in the array is valid.
    rpTokens            RPToken[]           @relation("UserRPToken")

    deleted             Boolean             @default(false)

    banned              Boolean             @default(false)
    banExpiration       DateTime?
    banMsg              String?
}



model Post {
    createdAt           DateTime            @default(now())
    updatedAt           DateTime            @updatedAt
    id                  String              @id @default(cuid())

    displayDate         DateTime            @default(now())

    // Seller who posted the post
    authorId            String
    author              User                @relation("UserPost", fields: [authorId], references: [id], onDelete: Cascade)

    // Has the post been deleted?
    deleted             Boolean             @default(false)

    // All reports this post has gotten
    reports             PostReport[]        @relation("ReportedPost")

    content             String
    media               String[]
    hasLocation         Boolean
    lat                 Decimal?
    lng                 Decimal?
    pinned              Boolean             @default(false)

    likeCount           Int                 @default(0)
    likes               Like[]              @relation("PostLikes")

    replyToId           String?             // ID of the post this post is replying to
    replyTo             Post?               @relation("PostReplies", fields: [replyToId], references: [id])

    replyCount          Int                 @default(0)
    replies             Post[]              @relation("PostReplies")

    // Root post: Empty.
    // Reply post: Contains all direct ancestor posts. FIrst post is the root.
    threadPosts         Post[]              @relation("ThreadPosts")

    // Unused.
    // Stores all the posts that have this post as an ancestor.
    threadOf            Post[]              @relation("ThreadPosts")
}



// A user's like on a post.
// Separate model to improve database operations and lookups.
model Like {
    id                 String              @id @default(cuid())
    createdAt          DateTime            @default(now())
    
    userId             String
    user               User                @relation("UserLikes", fields: [userId], references: [id], onDelete: Cascade)
    
    postId             String
    post               Post                @relation("PostLikes", fields: [postId], references: [id], onDelete: Cascade)

    @@unique([userId, postId])
    @@index([postId])
    @@index([userId])
}



// Account activation tokens, sent by email
model ActivateToken {
    createdAt           DateTime            @default(now())
    updatedAt           DateTime            @updatedAt
    id                  String              @id @default(cuid())

    token               String              @unique
    // The amount of (unsuccessful) times a user has tried to use this activate token to activate account
    // If too many are attempted, most likely a malicious user is guessing - mark the token as expired
    // "expired" is not to be used in any other context, tokens are automatcially deleted after a set time
    attempts            Int                 @default(0)
    expired             Boolean             @default(false)

    displayName         String
    username            String              @unique
    email               String              @unique
    password            String
    salt                String
}



// Token given to users to authorize account actions
model AuthToken {
    createdAt           DateTime            @default(now())
    updatedAt           DateTime            @updatedAt
    id                  String              @id @default(cuid())

    token               String              @unique

    userId              String
    user                User                @relation("UserAuthToken", fields: [userId], references: [id], onDelete: Cascade)
}



// Token send to a user's email to reset password
model RPToken {
    createdAt           DateTime            @default(now())
    updatedAt           DateTime            @updatedAt
    id                  String              @id @default(cuid())

    token               String
    // The amount of (unsuccessful) times a user has tried to use this RP token to reset a password
    // If too many are attempted, most likely a malicious user is guessing - mark the token as expired
    // "expired" is not to be used in any other context, tokens are automatcially deleted after a set time
    attempts            Int                 @default(0)
    expired             Boolean             @default(false)

    userId              String
    user                User                @relation("UserRPToken", fields: [userId], references: [id], onDelete: Cascade)
}



// Reporter is required, but if an account is deleted the reports still are available in the database (hence the "?"s)
model PostReport {
    createdAt           DateTime            @default(now())
    updatedAt           DateTime            @updatedAt
    id                  String              @id @default(cuid())

    msg                 String

    reporterId          String?
    reporter            User?               @relation("Reporter", fields: [reporterId], references: [id], onDelete: SetNull)

    reportedPostId      String
    reportedPost        Post                @relation("ReportedPost", fields: [reportedPostId], references: [id], onDelete: Cascade)
}